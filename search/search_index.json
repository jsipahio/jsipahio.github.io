{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"John Sipahioglu Instructor, Computer Science - Stark State College PhD Student, Kent State University Eventually, I will clean up this site to have all my info. For now, it has info sheets/\"eBooks\" for my courses.","title":"Home"},{"location":"#john-sipahioglu","text":"","title":"John Sipahioglu"},{"location":"#instructor-computer-science-stark-state-college","text":"","title":"Instructor, Computer Science - Stark State College"},{"location":"#phd-student-kent-state-university","text":"Eventually, I will clean up this site to have all my info. For now, it has info sheets/\"eBooks\" for my courses.","title":"PhD Student, Kent State University"},{"location":"CSE122/","text":"CSE122 This is mostly setup help for students who cannot, or do not wish to, use Visual Studio. Students on Mac (or Linux or Windows) can follow these instructions to install the .NET SDK, Visual Studio Code, and create and run .NET console apps from the command line. - Setup - This provides instructions to install .NET and VS Code, and test that they are working. - .NET Commands - This provides instructions for how to create your labs and open them in VS Code. - Terminal Basics - This provides instructions for navigating a terminal shell, if you would like to get more familiar with that. This one is mostly optional, but may be helpful if you get stuck with something in the terminal, or just want to learn more.","title":"CSE122"},{"location":"CSE122/#cse122","text":"This is mostly setup help for students who cannot, or do not wish to, use Visual Studio. Students on Mac (or Linux or Windows) can follow these instructions to install the .NET SDK, Visual Studio Code, and create and run .NET console apps from the command line. - Setup - This provides instructions to install .NET and VS Code, and test that they are working. - .NET Commands - This provides instructions for how to create your labs and open them in VS Code. - Terminal Basics - This provides instructions for navigating a terminal shell, if you would like to get more familiar with that. This one is mostly optional, but may be helpful if you get stuck with something in the terminal, or just want to learn more.","title":"CSE122"},{"location":"CSE122/dotnet_commands/","text":".NET Commands To create and run your Visual Basic applications, you will need to use the .NET command line interface (CLI). This is the bare minimum amount of terminal usage you will have to do for this class, if you are not using Visual Studio. First things first, you will need to open your project in VS Code. To create a new project, the first thing you should do is create a new folder for your project to go in. You can do this using your file explorer (Windows File Explorer, Mac Finder) application, or the terminal, if you are comfortable with it. Figure 1: New folder created for lab assignment Once you've created the folder, open VS Code and you will have the option to \"Open Folder...\" from the Welcome screen, or by clicking the \"File\" dropdown in the top-left corner and selecting \"Open Folder...\". Open folder locations in VS Code VS Code will open your file explorer application, and you can navigate to and select the folder you just created for your lab project. Make sure to select the lab folder, and not the one containing it. The bar at the bottom says \"Folder: week3-lab\", which is what we want. You do not want to open the \"CSE122\" folder This will open your folder in VS Code. It may ask if you trust the authors. Since you are the author, you should select \"Yes\". If you look at the file listing on the left side of the VS Code window, you may notice that it is empty. If you see a bunch of files, you probably selected the wrong folder. You should go to the File tab, select \"Close Folder\", then try opening your lab folder again. Empty Explorer in VS Code. If this is not open, click the icon that looks like a paper with the corner folded over that you see highlighted in this screenshot To create the project files, you should open the integrated terminal by holding the control (CTRL) key and pressing ~. The ~ key is to the left of the \"1\" key on your keyboard. The terminal will automatically be created in the folder that you have open in VS Code. In the terminal, type dotnet new console --language VB . This will create a subfolder called obj , a configuration file that has the same name as your folder with a vbproj extension, and a file called Program.vb . Program.vb contains the source code for your lab, and is the only file you actually have to interact with. You should see these files in the explorer on the left side of the VS Code window now: These are the default console app files for a Visual Basic project. Use the Program.vb file as your starting point for all your labs To test the lab, type dotnet run in the terminal. This will compile and run your lab. The message \"Hello World!\" should be printed to the terminal once it completes. Important .NET Commands To test that .NET is installed, run dotnet --list-sdks . It should print out a number and file path, such as \"10.0.100 [/usr/share/dotnet/sdk]\". If it doesn't, you will need to try reinstalling .NET. To create a new console application in Visual Basic, run the command dotnet new console --language vb in the folder you want to create the VB project in. You may want to double check you are in the right folder by first running the command pwd , to print the current folder the terminal is accessing. To compile and run your lab, run the command dotnet run . When we write programs that have user input, you will enter your input into the same terminal you ran the lab from.","title":"Dotnet commands"},{"location":"CSE122/dotnet_commands/#net-commands","text":"To create and run your Visual Basic applications, you will need to use the .NET command line interface (CLI). This is the bare minimum amount of terminal usage you will have to do for this class, if you are not using Visual Studio. First things first, you will need to open your project in VS Code. To create a new project, the first thing you should do is create a new folder for your project to go in. You can do this using your file explorer (Windows File Explorer, Mac Finder) application, or the terminal, if you are comfortable with it. Figure 1: New folder created for lab assignment Once you've created the folder, open VS Code and you will have the option to \"Open Folder...\" from the Welcome screen, or by clicking the \"File\" dropdown in the top-left corner and selecting \"Open Folder...\". Open folder locations in VS Code VS Code will open your file explorer application, and you can navigate to and select the folder you just created for your lab project. Make sure to select the lab folder, and not the one containing it. The bar at the bottom says \"Folder: week3-lab\", which is what we want. You do not want to open the \"CSE122\" folder This will open your folder in VS Code. It may ask if you trust the authors. Since you are the author, you should select \"Yes\". If you look at the file listing on the left side of the VS Code window, you may notice that it is empty. If you see a bunch of files, you probably selected the wrong folder. You should go to the File tab, select \"Close Folder\", then try opening your lab folder again. Empty Explorer in VS Code. If this is not open, click the icon that looks like a paper with the corner folded over that you see highlighted in this screenshot To create the project files, you should open the integrated terminal by holding the control (CTRL) key and pressing ~. The ~ key is to the left of the \"1\" key on your keyboard. The terminal will automatically be created in the folder that you have open in VS Code. In the terminal, type dotnet new console --language VB . This will create a subfolder called obj , a configuration file that has the same name as your folder with a vbproj extension, and a file called Program.vb . Program.vb contains the source code for your lab, and is the only file you actually have to interact with. You should see these files in the explorer on the left side of the VS Code window now: These are the default console app files for a Visual Basic project. Use the Program.vb file as your starting point for all your labs To test the lab, type dotnet run in the terminal. This will compile and run your lab. The message \"Hello World!\" should be printed to the terminal once it completes.","title":".NET Commands"},{"location":"CSE122/dotnet_commands/#important-net-commands","text":"To test that .NET is installed, run dotnet --list-sdks . It should print out a number and file path, such as \"10.0.100 [/usr/share/dotnet/sdk]\". If it doesn't, you will need to try reinstalling .NET. To create a new console application in Visual Basic, run the command dotnet new console --language vb in the folder you want to create the VB project in. You may want to double check you are in the right folder by first running the command pwd , to print the current folder the terminal is accessing. To compile and run your lab, run the command dotnet run . When we write programs that have user input, you will enter your input into the same terminal you ran the lab from.","title":"Important .NET Commands"},{"location":"CSE122/setup/","text":"Setup Help This guide aims to help students who cannot, or wish not to, use Visual Studio for CSE122, programming logic and problem solving. This guide is applicable to all operating systems, with some minor variations. As an alternative to Visual Studio, you may use Visual Studio Code (commonly referred to as VS Code, or just Code) and manually install the .NET SDK (Software Development). You will have to learn to operate a terminal a bit to use this method, but I think this is a good skill to have. Step 1: Install VS Code If you go to this link (https://code.visualstudio.com/), the website should (as long as you don't have a browser/settings that hide it) detect your operating system and processor. There will be a Download button at the top of page, with the name of your OS. If the OS is wrong, or if you don't see the Download button, go here (https://code.visualstudio.com/Download) and select the Download that matches your OS and CPU. It will likely take a minute or two to download. Once it finishes, run the installer. The default settings for the install will be fine. Once finished, verify that you can open VS Code. Once you've checked it, go ahead and close it while we install the .NET SDK. Step 2: Install the .NET SDK The .NET SDK installs the dotnet command line tool, along with the compilers and project templates for .NET languages (C#, F#, and Visual Basic). This link (https://dotnet.microsoft.com/en-us/download) should automatically detect your OS/CPU architecture and provide the correct installer download. If it does not, go here (https://dotnet.microsoft.com/en-us/download/dotnet/10.0) and find the version that matches your OS. Windows users with Intel or AMD processors should choose Windows x64. Windows users with a Snapdragon processor should choose Windows Arm64. Mac users should choose Mac x64 if they have an Intel CPU, or Arm64 if they have an Apple Silicon (M1/2/3/4). Once you've downloaded the installer (again, it may take a couple minutes), run it and click through until you get the option to install. Step 3: Verify Installation Open VS Code. You can open an integrated terminal session within VS Code by holding the CTRL key and pressing \"~\" (the key to the left of \"1\"). You should get a terminal at the bottom of your screen, similar to what is shown below: In it, type the following command: dotnet --list-sdks You should get output similar to the following: Let's create a new directory to create a test project in. In your terminal, type: mkdir vb-test This creates a directory (aka folder) called \"vb-test\". Now, let's enter that directory, using the cd command. cd is short for change directory. cd vb-test Now, we will create a new Visual Basic console application in this directory using the command below: dotnet new console --language vb This will automatcally generate the files required to create and run a Visual Basic Console application. Running ls -la in the terminal will display the files. You want to see something similar to the output below: The single period represents the current directory, and the .. is for the parent directory. We don't really care about those. What are important are the Program.vb , obj and vb-test.vbproj . The Program.vb file contains the source code for your program. The obj directory contains some generated files required by .NET. The vb-test.vbproj files are instructions for the .NET compiler. If these file are all present, you can try building and running you project with the following command. This should print \"Hello World!\" to the terminal: dotnet run Expected output: If you've gotten to this point, congratulations! Your installation of VS Code and .NET have been successful. Step 4: Setting Up for the Rest of the Semester Now that you have your installation verified, I'd recommend getting a folder set up for the rest of the semester. Either using the terminal, or your file explorer GUI, create a folder for this class wherever you'd like. We have 6 Visual Basic labs in this class, in Weeks 3, 5, 8, 10, 12, and 14. These correspond to chapters 2, 3, 4, 5, 6, and 9 from the book. Make a folder for each, using either the week or chapter numbers to keep them separate. Now, when the time comes, you can go to \"File in the top right corner of VS Code, select \"Open folder\", and navigate to the correct lab folder for the week we are on. Then, you can open a terminal in VS Code using CTRL + ~, and running dotnet new console --language vb . You can edit your Program.vb source code file by clicking on it in the list of files on the left side of the VS Code window. To test your code, run dotnet run in the terminal. Step 5: Check the Terminal Basics Doc I've also included a \"Terminal Basics\" sheet under this class. This will provide you with some of the basics of using a command line interface. I've tried to do this in a way that avoids the terminal as much as possible, but there are instances where it is needed. Troubleshooting As the semester goes on, I'll add issues that people encounter to this troubleshooting guide, so you can check back here if you have any issues. Issue: When running dotnet --list-sdks , I get a message to the effect of \"dotnet is not a valid command\". Solution: This means that the dotnet tool is not installed, or did not get added to your systems path. Follow the instructions under \"Step 2: Install the .NET SDK\". If you are sure that it is installed correctly, the issue is likely that the dotnet command line tool did not get added to your system's path. Windows - In the search box in the task bar, search \"environment variables\". If you are on a computer only you use, you can edit the System or \"Your Account\" variables. If it is a shared computer, edit the variables for your account. - In the top of the box, click Path to highlight it, and click the \"Edit...\" button. - A new box should pop up. Click the \"New\" button. This will allow you to type into the next unused row. - The default path for dotnet is \"C:\\Program Files\\dotnet\". Enter that into the box Mac - The only way this would happen is if you installed .NET to a non-standard location. I'd recommend running the installer again, uninstalling, and installing it again. If you still issues, contact me. All - After following the steps for your OS, attempt to perform step 3 again to verify the installation. Issue: When I try running dotnet run , I get this message: \"Couldn't find a project to run. Ensure a project exists in /workspaces/jsipahio.github.io, or pass the path to the project using --project.\" Solution: This indicates that your terminal is not in the same directory as your project. If you are not comfortable with using a terminal to navigate your file system, navigate to your project folder using your file explorer application. Make sure you are in the folder, you should see your Program.vb and .vbproj files. Copy the path by right clicking the path in the top bar. Select \"Copy as text\" if you are on Windows. Mac users should hold the Option key while right clicking, and select \"Copy name_of_folder As Pathname\". Go back to the terminal, type cd , add a space, then paste in the path you just copied. Hit enter. This should change your terminal's directory into the correct one. Try running dotnet run again.","title":"Setup Help"},{"location":"CSE122/setup/#setup-help","text":"This guide aims to help students who cannot, or wish not to, use Visual Studio for CSE122, programming logic and problem solving. This guide is applicable to all operating systems, with some minor variations. As an alternative to Visual Studio, you may use Visual Studio Code (commonly referred to as VS Code, or just Code) and manually install the .NET SDK (Software Development). You will have to learn to operate a terminal a bit to use this method, but I think this is a good skill to have.","title":"Setup Help"},{"location":"CSE122/setup/#step-1-install-vs-code","text":"If you go to this link (https://code.visualstudio.com/), the website should (as long as you don't have a browser/settings that hide it) detect your operating system and processor. There will be a Download button at the top of page, with the name of your OS. If the OS is wrong, or if you don't see the Download button, go here (https://code.visualstudio.com/Download) and select the Download that matches your OS and CPU. It will likely take a minute or two to download. Once it finishes, run the installer. The default settings for the install will be fine. Once finished, verify that you can open VS Code. Once you've checked it, go ahead and close it while we install the .NET SDK.","title":"Step 1: Install VS Code"},{"location":"CSE122/setup/#step-2-install-the-net-sdk","text":"The .NET SDK installs the dotnet command line tool, along with the compilers and project templates for .NET languages (C#, F#, and Visual Basic). This link (https://dotnet.microsoft.com/en-us/download) should automatically detect your OS/CPU architecture and provide the correct installer download. If it does not, go here (https://dotnet.microsoft.com/en-us/download/dotnet/10.0) and find the version that matches your OS. Windows users with Intel or AMD processors should choose Windows x64. Windows users with a Snapdragon processor should choose Windows Arm64. Mac users should choose Mac x64 if they have an Intel CPU, or Arm64 if they have an Apple Silicon (M1/2/3/4). Once you've downloaded the installer (again, it may take a couple minutes), run it and click through until you get the option to install.","title":"Step 2: Install the .NET SDK"},{"location":"CSE122/setup/#step-3-verify-installation","text":"Open VS Code. You can open an integrated terminal session within VS Code by holding the CTRL key and pressing \"~\" (the key to the left of \"1\"). You should get a terminal at the bottom of your screen, similar to what is shown below: In it, type the following command: dotnet --list-sdks You should get output similar to the following: Let's create a new directory to create a test project in. In your terminal, type: mkdir vb-test This creates a directory (aka folder) called \"vb-test\". Now, let's enter that directory, using the cd command. cd is short for change directory. cd vb-test Now, we will create a new Visual Basic console application in this directory using the command below: dotnet new console --language vb This will automatcally generate the files required to create and run a Visual Basic Console application. Running ls -la in the terminal will display the files. You want to see something similar to the output below: The single period represents the current directory, and the .. is for the parent directory. We don't really care about those. What are important are the Program.vb , obj and vb-test.vbproj . The Program.vb file contains the source code for your program. The obj directory contains some generated files required by .NET. The vb-test.vbproj files are instructions for the .NET compiler. If these file are all present, you can try building and running you project with the following command. This should print \"Hello World!\" to the terminal: dotnet run Expected output: If you've gotten to this point, congratulations! Your installation of VS Code and .NET have been successful.","title":"Step 3: Verify Installation"},{"location":"CSE122/setup/#step-4-setting-up-for-the-rest-of-the-semester","text":"Now that you have your installation verified, I'd recommend getting a folder set up for the rest of the semester. Either using the terminal, or your file explorer GUI, create a folder for this class wherever you'd like. We have 6 Visual Basic labs in this class, in Weeks 3, 5, 8, 10, 12, and 14. These correspond to chapters 2, 3, 4, 5, 6, and 9 from the book. Make a folder for each, using either the week or chapter numbers to keep them separate. Now, when the time comes, you can go to \"File in the top right corner of VS Code, select \"Open folder\", and navigate to the correct lab folder for the week we are on. Then, you can open a terminal in VS Code using CTRL + ~, and running dotnet new console --language vb . You can edit your Program.vb source code file by clicking on it in the list of files on the left side of the VS Code window. To test your code, run dotnet run in the terminal.","title":"Step 4: Setting Up for the Rest of the Semester"},{"location":"CSE122/setup/#step-5-check-the-terminal-basics-doc","text":"I've also included a \"Terminal Basics\" sheet under this class. This will provide you with some of the basics of using a command line interface. I've tried to do this in a way that avoids the terminal as much as possible, but there are instances where it is needed.","title":"Step 5: Check the Terminal Basics Doc"},{"location":"CSE122/setup/#troubleshooting","text":"As the semester goes on, I'll add issues that people encounter to this troubleshooting guide, so you can check back here if you have any issues. Issue: When running dotnet --list-sdks , I get a message to the effect of \"dotnet is not a valid command\". Solution: This means that the dotnet tool is not installed, or did not get added to your systems path. Follow the instructions under \"Step 2: Install the .NET SDK\". If you are sure that it is installed correctly, the issue is likely that the dotnet command line tool did not get added to your system's path. Windows - In the search box in the task bar, search \"environment variables\". If you are on a computer only you use, you can edit the System or \"Your Account\" variables. If it is a shared computer, edit the variables for your account. - In the top of the box, click Path to highlight it, and click the \"Edit...\" button. - A new box should pop up. Click the \"New\" button. This will allow you to type into the next unused row. - The default path for dotnet is \"C:\\Program Files\\dotnet\". Enter that into the box Mac - The only way this would happen is if you installed .NET to a non-standard location. I'd recommend running the installer again, uninstalling, and installing it again. If you still issues, contact me. All - After following the steps for your OS, attempt to perform step 3 again to verify the installation. Issue: When I try running dotnet run , I get this message: \"Couldn't find a project to run. Ensure a project exists in /workspaces/jsipahio.github.io, or pass the path to the project using --project.\" Solution: This indicates that your terminal is not in the same directory as your project. If you are not comfortable with using a terminal to navigate your file system, navigate to your project folder using your file explorer application. Make sure you are in the folder, you should see your Program.vb and .vbproj files. Copy the path by right clicking the path in the top bar. Select \"Copy as text\" if you are on Windows. Mac users should hold the Option key while right clicking, and select \"Copy name_of_folder As Pathname\". Go back to the terminal, type cd , add a space, then paste in the path you just copied. Hit enter. This should change your terminal's directory into the correct one. Try running dotnet run again.","title":"Troubleshooting"},{"location":"CSE122/terminal_basics/","text":"Terminal Basics This fact sheet will help familiarize you with the terminal shell. In Linux and Mac, the application to access the shell is typically called \"Terminal\". In Windows, you can use Command Prompt (cmd.exe) or PowerShell (powershell.exe). You can also open a terminal in VS Code by holding the control (CTRL) key and pressing ~, which is to the left of your \"1\" key. On Windows, VS Code opens PowerShell by default, which I would recommend using. Command Cheat Sheet Here is a a list of commonly used commands in the terminal shell. Note that these are for Mac/Linux, although PowerShell aliases many of its commands to match these. The commands for Command Prompt are totally different, in many cases. man (manual) - this command will print the help manual for whatever command/program you pass it, assuming that a manual is available for it. The manual can be navigated using PgUp and PgDn , and exited by pressing q on your keyboard. (On most modern Linux systems you can also scroll with the mouse) pwd (print working directory) - this command prints your current working directory in the file system. It is important to be aware of the directory you are in, and how to navigate the file system so you are working in the correct location ls (list) - this command shows you the directory listing, i.e., the list of all the files in and subdirectories in the directory ls is querying. Below are some of the command switches -l - this switch changes the output to be in a more detailed list that shows you permissions, last access/modify date and time, and the size of file -a - this switch shows hidden files and directories. In Linux, directories that start with a period are hidden -h - this switch converts the bytes of a file's size into a more human-readable format, like kilobytes, megabytes, or gigabytes, depending on the size of the file The switches can be combined like the following: ls -lah (the order of the switches is not important, -ahl would do the same thing) By default, ls shows the listing for the current directory. But, you can pass it another directory as an argument: ls -l /var/log cd (change directory) - this command is used to change your working directory. It takes one argument, the directory you want to chage to. mkdir (make directory) - this command is used to create a new directory. -p - this switch is used to create intermediate directories if they don't exist cp (copy) - this command is used to copy files or directories from a source to a destination. Below are some common switches: -b - backup destination files -r - recursively copy, this is used to copy directories and subdirectories. By default, directories are skipped without this flag -f - force. If you try to copy over a file and that file is in use, it will attempt to force delete the destination file to complete the copy action -i - interactive. This will prompt you to answer yes or no before overwriting a file. By default, existing files are overwritten without warning -n - no-clobber. Blocks existing files from being overwritten mv (move) - this command will move a file from one location to another. Also, renaming a file is technically a \"move\" operation, so mv can be used to rename a file as well. -b - backup destination files -f - force. Always overwrite destination -i - interactive. Prompt before overwrite -n - no clobber. Never overwrite destination -u - update. Only update destination if it is older than the source or does not exist 'rm (remove) - this command will delete files and directories. Note that this will delete files permanently (there is not a recycle bin when using rm ) - -f - ignore if file is missing (in PowerShell, use -Force instead) - -i - prompt before each removal - -r - remove directories and their children recursively - -d - remove empty directories Understanding the Command Line Environment When using the terminal, you are interacting with your computer's filesystem using a text based interface. You are hopefully somewhat familiar with navigating your file system using your file explorer application provided by the operating system (File Explorer on Windows, Finder on Mac, Files on Ubuntu Linux, etc.). When you click your file explorer application, you get a GUI window that shows icons for the various files and folders you have. These files and folders themselves are contained within a folder in your file system. By default, Windows File Explorer opens to a Favorites and Recently accessed files screen, which is not an actual folder. Rather, it is a collection of folders. On Mac, Finder opens up your home directory, which contains your Desktop, Documents, iTunes, etc. folders. If you open a blank window in VS Code and open a terminal (using CTRL + ~), the terminal opens you your user directory (remember, directories in the terminal correspond to folders in file explorer). On Mac, your user directory is likely /Users/<your-username> . On Windows, it is typically C:\\Users\\<your-username> . This folder contains your Desktop, Documents, Downloads, etc. folders. You can check this by running the ls command. This command lists the files and directories conatained in the current directory. To check the name of the directory you are currently in, you can use the pwd (print working directory) command. So, what if I am in /Users/john/ , and want to get to my Desktop folder? I can use the cd (change directory) command to do so. If I type cd Desktop , I will change directory to the Desktop folder within the current directory, /Users/john, that I am in. Now, if I run pwd , I will see that I am in /Users/john/Desktop/ . If I run ls , I will see all the files and folders that are contained within my Desktop folder. You can verify this by checking your own Desktop folder versus the list of files you get running ls . Your computer's directory has a tree-like structure. It starts with a root, which is represented by a / on Mac and C:\\ on Windows. Below is the typical, default directory structure of a Windows and Mac filesystem: Note: your computer may vary slightly from this, that is okay Windows C:\\ Program Files Program Files (x86) Users Administrator Guest <your-username> Desktop Documents Photos Downloads Windows Mac / bin boot dev etc lib home media mnt proc opt proc run srv sys usr Users <your-username> Desktop Documents Downloads iTunes var For the sake of this class, you only need to worry about the folders and files that are \"branches\" and \"leaves\" of directory that is your username, which is why I have only \"expanded\" those directories in the diagrams above. Returning to the example from a couple paragraphs ago, I have changed directory into /Users/john/Desktop/. But, what if I want to go back a directory? Terminal shells reserve two periods, .. , for this purpose. If I run the command cd .. , it will change my directory from /Users/john/Desktop/ to /Users/john/. If I run cd .. again, I will change directory from /Users/john/ to /Users/. If I wanted to get back to my Desktop folder, I would first have to cd john to get back to /Users/john/, then cd Desktop to get to /Users/john/Desktop/. Alternatively, I could provide the whole path to my Desktop folder, with the command cd john/Desktop . This would let me change from /Users/ to /Users/john/Desktop/ in a single command. As an example, let's say that this is what my (simplified) directory structure looks like: / Users john Desktop CSE122 lab1 lab1.vbproj obj Program.vb lab2 NET120 Documents Downloads Assume I am in a terminal, and run the command pwd . The output I get is /Users/john/Downloads/ . There are two things I want to accomplish. First, I want to get to my \"lab1\" and run the program. Secondly, I want to create the Visual Basic console app project for my \"lab2\". If we look at the directory tree, we can see that both lab1 and lab2 are directories contained within the directory \"CSE122\". \"CSE122\" is contained in my \"Desktop\" directory, which is under my name. Currently, I am in /Users/john/Downloads/. \"Desktop\" is directly below \"john\", so I first want to get to \"/Users/john/\". To do so, I can use cd .. to move up one directory. Running this command will change my location from /Users/john/Downloads/ to /Users/john/ . Now, I want to get to my \"Desktop\" folder. Since it is directly below \"john\" in the directory tree, I can use cd Desktop to get there. If I run pwd , my current directory is now /Users/john/Desktop/ . However, lab1 and lab2 are in \"CSE122\", not Desktop. \"CSE122\" is directly below Desktop, so to get there I can use cd CSE122 . I am now in /Users/john/Desktop/CSE122 . The first thing I wanted to do was to run my lab1 project. To do so, I should be in the \"lab1\" directory. Once again, I will use cd to get there. cd lab1 will put me in /Users/john/Desktop/CSE122/lab1/ . From here, I can run the command dotnet run to compile and execute my lab1 project. Next, I wanted to create a new project for lab2. The \"lab2\" directory is directly below \"CSE122\", and is not contained within \"lab1\" (use the indention to determine the level of a directory/file). Therefore, to get to \"lab2\", I must first use cd .. to exit the \"lab1\" directory and return to /Users/john/Desktop/CSE122 . Now, I can use cd lab2 to enter the directory /Users/john/Desktop/CSE122/lab2 . To create a new Visual Basic console app project, type the command dotnet new console --language VB . This will create the starter files required for a basic Visual Basic console app. If you run the ls command in the \"lab2\" directory, you will see that it has created a new directory called obj , a file called Program.vb , and a file called lab2.vbproj . Below is an example of the terminal I/O for this example. Lines that start with > are user input lines. Lines that start with # are comments, and are not part of the actual terminal I/O. Lines that do not start with any special characters are the terminal output. # checking my current directory > pwd /Users/john/Downloads # changing directory to my /User/john home directory > cd .. # displaying file listing > ls Desktop Documents Downloads # changing to Desktop and checking contents > cd Desktop > ls CSE122 NET120 # changing to CSE122 and checking contents > cd CSE122 > ls lab1 lab2 # changing to lab1 and running project > cd lab1 > dotnet run Hello World! # moving back a directory so I can change to lab2 > cd .. > cd lab2 # creating a new VB console app in lab2 > dotnet new console --language vb # there is a lot of text output when this happens that is not included here > ls lab2.vbproj obj Program.vb > dotnet run Hello World! >","title":"Terminal basics"},{"location":"CSE122/terminal_basics/#terminal-basics","text":"This fact sheet will help familiarize you with the terminal shell. In Linux and Mac, the application to access the shell is typically called \"Terminal\". In Windows, you can use Command Prompt (cmd.exe) or PowerShell (powershell.exe). You can also open a terminal in VS Code by holding the control (CTRL) key and pressing ~, which is to the left of your \"1\" key. On Windows, VS Code opens PowerShell by default, which I would recommend using.","title":"Terminal Basics"},{"location":"CSE122/terminal_basics/#command-cheat-sheet","text":"Here is a a list of commonly used commands in the terminal shell. Note that these are for Mac/Linux, although PowerShell aliases many of its commands to match these. The commands for Command Prompt are totally different, in many cases. man (manual) - this command will print the help manual for whatever command/program you pass it, assuming that a manual is available for it. The manual can be navigated using PgUp and PgDn , and exited by pressing q on your keyboard. (On most modern Linux systems you can also scroll with the mouse) pwd (print working directory) - this command prints your current working directory in the file system. It is important to be aware of the directory you are in, and how to navigate the file system so you are working in the correct location ls (list) - this command shows you the directory listing, i.e., the list of all the files in and subdirectories in the directory ls is querying. Below are some of the command switches -l - this switch changes the output to be in a more detailed list that shows you permissions, last access/modify date and time, and the size of file -a - this switch shows hidden files and directories. In Linux, directories that start with a period are hidden -h - this switch converts the bytes of a file's size into a more human-readable format, like kilobytes, megabytes, or gigabytes, depending on the size of the file The switches can be combined like the following: ls -lah (the order of the switches is not important, -ahl would do the same thing) By default, ls shows the listing for the current directory. But, you can pass it another directory as an argument: ls -l /var/log cd (change directory) - this command is used to change your working directory. It takes one argument, the directory you want to chage to. mkdir (make directory) - this command is used to create a new directory. -p - this switch is used to create intermediate directories if they don't exist cp (copy) - this command is used to copy files or directories from a source to a destination. Below are some common switches: -b - backup destination files -r - recursively copy, this is used to copy directories and subdirectories. By default, directories are skipped without this flag -f - force. If you try to copy over a file and that file is in use, it will attempt to force delete the destination file to complete the copy action -i - interactive. This will prompt you to answer yes or no before overwriting a file. By default, existing files are overwritten without warning -n - no-clobber. Blocks existing files from being overwritten mv (move) - this command will move a file from one location to another. Also, renaming a file is technically a \"move\" operation, so mv can be used to rename a file as well. -b - backup destination files -f - force. Always overwrite destination -i - interactive. Prompt before overwrite -n - no clobber. Never overwrite destination -u - update. Only update destination if it is older than the source or does not exist 'rm (remove) - this command will delete files and directories. Note that this will delete files permanently (there is not a recycle bin when using rm ) - -f - ignore if file is missing (in PowerShell, use -Force instead) - -i - prompt before each removal - -r - remove directories and their children recursively - -d - remove empty directories","title":"Command Cheat Sheet"},{"location":"CSE122/terminal_basics/#understanding-the-command-line-environment","text":"When using the terminal, you are interacting with your computer's filesystem using a text based interface. You are hopefully somewhat familiar with navigating your file system using your file explorer application provided by the operating system (File Explorer on Windows, Finder on Mac, Files on Ubuntu Linux, etc.). When you click your file explorer application, you get a GUI window that shows icons for the various files and folders you have. These files and folders themselves are contained within a folder in your file system. By default, Windows File Explorer opens to a Favorites and Recently accessed files screen, which is not an actual folder. Rather, it is a collection of folders. On Mac, Finder opens up your home directory, which contains your Desktop, Documents, iTunes, etc. folders. If you open a blank window in VS Code and open a terminal (using CTRL + ~), the terminal opens you your user directory (remember, directories in the terminal correspond to folders in file explorer). On Mac, your user directory is likely /Users/<your-username> . On Windows, it is typically C:\\Users\\<your-username> . This folder contains your Desktop, Documents, Downloads, etc. folders. You can check this by running the ls command. This command lists the files and directories conatained in the current directory. To check the name of the directory you are currently in, you can use the pwd (print working directory) command. So, what if I am in /Users/john/ , and want to get to my Desktop folder? I can use the cd (change directory) command to do so. If I type cd Desktop , I will change directory to the Desktop folder within the current directory, /Users/john, that I am in. Now, if I run pwd , I will see that I am in /Users/john/Desktop/ . If I run ls , I will see all the files and folders that are contained within my Desktop folder. You can verify this by checking your own Desktop folder versus the list of files you get running ls . Your computer's directory has a tree-like structure. It starts with a root, which is represented by a / on Mac and C:\\ on Windows. Below is the typical, default directory structure of a Windows and Mac filesystem: Note: your computer may vary slightly from this, that is okay Windows C:\\ Program Files Program Files (x86) Users Administrator Guest <your-username> Desktop Documents Photos Downloads Windows Mac / bin boot dev etc lib home media mnt proc opt proc run srv sys usr Users <your-username> Desktop Documents Downloads iTunes var For the sake of this class, you only need to worry about the folders and files that are \"branches\" and \"leaves\" of directory that is your username, which is why I have only \"expanded\" those directories in the diagrams above. Returning to the example from a couple paragraphs ago, I have changed directory into /Users/john/Desktop/. But, what if I want to go back a directory? Terminal shells reserve two periods, .. , for this purpose. If I run the command cd .. , it will change my directory from /Users/john/Desktop/ to /Users/john/. If I run cd .. again, I will change directory from /Users/john/ to /Users/. If I wanted to get back to my Desktop folder, I would first have to cd john to get back to /Users/john/, then cd Desktop to get to /Users/john/Desktop/. Alternatively, I could provide the whole path to my Desktop folder, with the command cd john/Desktop . This would let me change from /Users/ to /Users/john/Desktop/ in a single command. As an example, let's say that this is what my (simplified) directory structure looks like: / Users john Desktop CSE122 lab1 lab1.vbproj obj Program.vb lab2 NET120 Documents Downloads Assume I am in a terminal, and run the command pwd . The output I get is /Users/john/Downloads/ . There are two things I want to accomplish. First, I want to get to my \"lab1\" and run the program. Secondly, I want to create the Visual Basic console app project for my \"lab2\". If we look at the directory tree, we can see that both lab1 and lab2 are directories contained within the directory \"CSE122\". \"CSE122\" is contained in my \"Desktop\" directory, which is under my name. Currently, I am in /Users/john/Downloads/. \"Desktop\" is directly below \"john\", so I first want to get to \"/Users/john/\". To do so, I can use cd .. to move up one directory. Running this command will change my location from /Users/john/Downloads/ to /Users/john/ . Now, I want to get to my \"Desktop\" folder. Since it is directly below \"john\" in the directory tree, I can use cd Desktop to get there. If I run pwd , my current directory is now /Users/john/Desktop/ . However, lab1 and lab2 are in \"CSE122\", not Desktop. \"CSE122\" is directly below Desktop, so to get there I can use cd CSE122 . I am now in /Users/john/Desktop/CSE122 . The first thing I wanted to do was to run my lab1 project. To do so, I should be in the \"lab1\" directory. Once again, I will use cd to get there. cd lab1 will put me in /Users/john/Desktop/CSE122/lab1/ . From here, I can run the command dotnet run to compile and execute my lab1 project. Next, I wanted to create a new project for lab2. The \"lab2\" directory is directly below \"CSE122\", and is not contained within \"lab1\" (use the indention to determine the level of a directory/file). Therefore, to get to \"lab2\", I must first use cd .. to exit the \"lab1\" directory and return to /Users/john/Desktop/CSE122 . Now, I can use cd lab2 to enter the directory /Users/john/Desktop/CSE122/lab2 . To create a new Visual Basic console app project, type the command dotnet new console --language VB . This will create the starter files required for a basic Visual Basic console app. If you run the ls command in the \"lab2\" directory, you will see that it has created a new directory called obj , a file called Program.vb , and a file called lab2.vbproj . Below is an example of the terminal I/O for this example. Lines that start with > are user input lines. Lines that start with # are comments, and are not part of the actual terminal I/O. Lines that do not start with any special characters are the terminal output. # checking my current directory > pwd /Users/john/Downloads # changing directory to my /User/john home directory > cd .. # displaying file listing > ls Desktop Documents Downloads # changing to Desktop and checking contents > cd Desktop > ls CSE122 NET120 # changing to CSE122 and checking contents > cd CSE122 > ls lab1 lab2 # changing to lab1 and running project > cd lab1 > dotnet run Hello World! # moving back a directory so I can change to lab2 > cd .. > cd lab2 # creating a new VB console app in lab2 > dotnet new console --language vb # there is a lot of text output when this happens that is not included here > ls lab2.vbproj obj Program.vb > dotnet run Hello World! >","title":"Understanding the Command Line Environment"},{"location":"NET264/week1/","text":"NET264 - Unix/Linux System Administration: Week 1 Introduction Welcome to NET264 - Unix/Linux System Administration. The prerequisite to this course is NET220 - Unix/Linux Operating Environments, so you are expected to have some familiarity with Linux systems at this point. In this first week, we'll focus on the history of UNIX/Linux, discussing the duties for a Linux Network Administrator, and some information about man pages and getting help with Linux. Finally, we'll cover some of the installation options you can use to a Linux environment for this class. History of System Adminstrators For those of you reading the online 4th edition of the book, the section \"A Brief History of System Administration\" can be found after the Index, in the top level of the book's table of contents. The IBM 701 computer was completed in 1952, and was the first commercial computer system. It was quickly replaced 2 years later by the 704, which was totally incompatible with instructions written for the 701, as it used different word-sizes and added floating point arithmetic. The early operators of these systems layed the foundation for future SysAdmins. The informal meetings between these operators would lead to the IBM funded SHARE group, where operators would share experiences and software. SHARE continues to exist today (https://www.share.org/). These early computer systems were large and expensive, and only really designed to support a single user and task. Therefore, companies would only invest in one if they had a task that was so large and important that it was worth the expense of purchasing and maintaining it. At this point in time, the people in charge of the computers were viewed more as operators than administrators. This began to change in the 1960s, when research into designing multi-user computer systems began. One of the first attempts to develop such an operating system, Multics, was abandoned by the major research group AT&T Bell Labs after 5 years of failed development. Some remnants of this group, Ken Thompson, Rudd Canaday, and Dennis Ritchie, began working on a new system inspried by Multrics, but redesigned it to eliminate many of the pitfalls experienced when developing Multics. This system became known as UNIX, and was originally a small, single-user system. By 1971, this system began implementing many of the commands we still see today in modern Linux, such as as , cat , chdir (now cd ), chmod , chown , cmp , cp , date , and du . By 1973, the advant of the C programming language and idea of piping led to the increase in power of the UNIX operating system, along with a usage and design philosophy: - write programs that do one thing well - write programs that work together - write programs that handle text streams as a universal interface Over the next 15 or so years, the use of UNIX repidly expanded. Anti-trust rulings prevented AT&T from selling UNIX, forcing it to license it to other entities instead. One of the most important recipients of UNIX was Professor Robert Fabry at Cal Berkeley, leading the the development of Berkeley UNIX, later to be named the Berkeley Software Distribution (BSD), one of the OS's most famous distribution. Eventually, this development received funding from the US Defense Advanced Research Project Agency (DARPA). However, when AT&T was broken up do to later anti-trust rulings, it was then able to develop its own commercial distributions of UNIX and sell them. Eventually, this led to them suing Berkeley Sofware Design Inc. (BSDI) for stealing it's code. After 2 years, they were able to get a grand total of 3 out of over 18,000 files removed from BSD. However, this uncertainty led to many entities using UNIX to jump ship to Microsoft NT and Windows to avoid being at the mercy of AT&T. Meanwhile, in 1987, Professor Andrew S. Tanenbaum had released a simplified UNIX distribution called MINIX (mini-UNIX) with his book Operating Systems: Design and Implementation . This book and OS led to Linux Torvalds' development of the Linux kernel. The effect of this is that many UNIX SysAdmins shifted to learning Windows in the mid-1990s, to avoid losing their jobs due to their old skills no longer being relevant. As the dust cleared from the late 90s, it was clear that Windows was going to dominate the computing landscape. However, Linux continued to persist, and it became apparent that businesses would have to use both operating systems. Linux servers have much lower total cost of ownership (TCO) than Windows. Sys Admin Roles and Responsibilities The rest of the material in this week is from Chapter 1 of the textbook. If you are using the eBook on Safari, Chapter 1 is in Section One: Basic Administration. While system administrators are not software developers, one of thier major roles is scripting, which will be covered in the next two weeks. Here, we'll briefly discuss the other roles of SysAdmins: - Provisioning Accounts: This inclues adding new accounts for new users, deleting/deactivating accounts for people who no longer need them, and handling other account issues. - Performing Backups: A boring but critical part of being a SysAdmin. There is nothing exciting about backing up server drives, but are critical to ensuring business operations can continue if a server encounters drive damage. - Installing/Updating Software: New software must be tested before being distributed. Many companies disallow general employees from installing their own software, therefore, SysAdmins must also manage the distribution of new software. Additionally, SysAdmins must manage the updating of software, ensuring that new versions do not cause issues, or quickly distributing new updates that fix a security vulnerability. - System Monitoring: SysAdmins must keep track of the system at all times. Users generally will not notice or report minor issues. There are many software solutions for system monitoring that can aid in this task. - Troubleshooting: Admins must handle the process of diagnosing and fixing issues with the system. - Maintaining Local Documentation: Software and systems are configured to meet business needs, meaning additional documentation beyond what is provided by the software/system authors is required. - Monitoring Security: The SysAdmin is responsible for implementing the company security policy, and ensuring it is followed. They must also update the policy when neccessary to reflect changes, as software systems are constantly evolving. SysAdmins must also perform security audits to ensure that systems are not compromised. - Fire Fighting: Hopefully not literally... SysAdmins are responsible for assisting company employees with their computer issues, as well as handling major server failures. Manual Pages These are often abbreviated as \"man pages\", as the command man is used to view them. These are online documentation included with the system or software distribution, and provide information about the command/driver/file format/etc. These do not provide answers to general questions about how the software is working, but provide basic information on what the software does, and how to use it. The man command followed by the name of the command/file/etc. that you want information on is used to lookup the manual for that resource. The PAGER environment variable contains the program that is used to display the man page ( more , less , etc.). The section of the manual you want to view can be passed before the title of the resource to view the manual of. Most commands provide a one-line description. The -k followed by a keyword to search for will return all commands that contain the specified keyword in this description. For example: man -k copy asn1_copy_node (3) - API function bcopy (3) - copy byte sequence copy_file_range (2) - Copy a range of data from one file to another copysign (3) - copy sign of a number copysignf (3) - copy sign of a number copysignl (3) - copy sign of a number cp (1) - copy files and directories # ... many more results truncated Man pages are typically stored in directories under /usr/share/man/ . These pages are typically compressed using the gzip compression format, and decompressed when requested. The default search path(s) is(are) stored in the environment variable MANPATH , and can be checked using the manpath command. Beyond the included documentation installed with the system and software, much of the information can be found on the internet. Nowadays, pretty much all vendors provide documentation on their websites. Additionally, community forums exist where users and SysAdmins share problems and solutions. Requests for Comments (RFC) provide definitieve information on internet protocols and procedures. While they are very technical, anyone wanting to know the exact information about a protocol should read the associated RFC. Distros A distribution (often abbreviated to \"distro\") is the Linux kernel (the core operating system) bundled with additional software. All distros aim to provide simple installation, a package manager, and, in the case of desktop distros, some form of GUI and desktop. Many server installations do not ship with a GUI, and instead only run in terminal mode. When looking at distros for business use, it's important to consider the lifetime of the distribution, the vendor support, security update schedule, and if common software is compatible/frequently updated. There is a Linux family tree, of sorts, where there are few core distros that branch from the original kernel. For example, Debian GNU/Linux is one of the older Linux distributions. From Debian, distros including Ubuntu, Kali, and Knoppix are built off of it. Ubuntu is often called a \"cleaned-up\" version of Debian, and offers a more streamlined user experience. Furthermore, Linux Mint and Pop!_OS are built off of Ubuntu (and, by extension, also built off of Debian). Mint is often recommended as a first Linux distro to Windows users due to its simplicity and similarity to Windows' GUI. To provide a breadth of Linux distros, the book will sometimes discuss specifics of Ubuntu (Debian-based), openSUSE (SUSE based), Red Hat (RHEL-based). To provide details of operating systems more directly built off of UNIX, Solaris, HP-UX, and AIX will be discussed. Installation Options As you might imagine, you will need your own Linux environment for this class. There are several options to do so, which we'll discuss here: 1. Virtual Machine: This is the easiest and least intrusive option. One thing to note is that you may need to go into your computer's BIOS/UEFI settings and enable virtualization on your CPU. Then, you can install a hypervisor. If you have a professional or above version of Windows, you can enable Hyper-V by going to \"Turn Windows features on or off\". You can also install VMWare Workstation on Windows or VMWare Fusion on mac. However, I have heard that, while free, getting Broadcom (the new owner of VMWare) to provide the installer can be challenging. An option that works across operating systems is Oracle VirtualBox. This is a free and open source hypervisor that works on Windows, Mac, and Linux. Your \"host OS\" is the operating system installed on your computer, so make sure to choose the installer for Windows if you are on Windows, and Mac if you are on Mac. To install Linux, you will need to download the .iso file from the vendor (in this case, Ubuntu). For this class, you should use a desktop version. To create a new VM, select the correct option to create a new VM for your hypervisor. The steps will be slightly different, but you will need to tell it how many CPU cores and how much RAM to dedicate to the VM, and select a location to create the Virtual Hard Disk. You can do this on either your main computer's storage drive, or on an external hard drive you USB thumbdrive. Using a thumbdrive or external drive will be slower, but is an option if you do not have very much storage space remaining on your computer. 2. Separate Drive: You can partition and install Linux on a separate hard drive, either by installing an additional hard disk or SSD into your computer if it allows it, or an external hard drive. If it is an external drive, you'll need to make it bootable. A SATA connected drive will be detected as bootable as soon as you install the OS. To install Linux, you will need to download the .iso file from the vendor, in this case, Ubuntu desktop. Next, you will need a USB flash drive large enough (8GB for newer Ubuntu versions, some older ones may work with 4GB) to store the Linux ISO. Rufus is a commonly used tool for this purpose. Here are the instructions from Ubuntu (https://documentation.ubuntu.com/desktop/en/latest/how-to/create-a-bootable-usb-stick/#on-windows) to create a bootable USB on Windows. There are instructions for Mac below the Windows Section. 3. Dual-Boot on Same Drive : This is the most advanced option. You'll need to go into Windows drive management and shrink your Windows partition. 20GB is the minimum recommended amount of drive space for installing Ubuntu. Once you shrink your Windows partition, you'll need to create a bootable CD or USB (same process as option 2) to install Linux. You then need to restart your computer, enter BIOS/UEFI, and boot from the USB. Then, when using the Linux installer, you should see the unallocated space created by shrinking your Windows partition. Use all this space for Linux. Note: A VM is by far the easiest and cheapest option. I would only recommend the other options if you would like to use Linux as an alternate OS in your day-to-day life. Anything for this class, or even any testing you do in the future, can be done using a VM. Installing Linux Once you get to this point, the steps to install Linux will be the same. You will need to configure the partition table for your Linux system. The first 512 bytes should be dedicated for EFI Boot. The next section is the root (signified by a single forward slash / ). Use \"ext4\" as the file system. I'd recommend dedicating at least 4 GB of RAM to it, but 8 would be better, if you have enough storage. If your VM or computer (depending on the install option) has more than 8 GB of RAM, you can dedicate the rest of the free space to the /home directory. This should also use the ext4 file system. If you have less than 8GB of RAM, I'd recommend dedicating all but 4GB of the remaining free space to /home . After home, add an additional \"swap\" partition. This will provide the OS with virtual RAM to use if it runs out of main memory. From here, you can pretty much just click through all the boxes and the installation will proceed. If you are not using a VM, you may want to consider going back into BIOS/UEFI settings and making your Linux drive/partition the first option. This way, the GRUB menu will appear when you start your system and you can choose whether to boot Linux, or your original OS. Otherwise, you will have to go into BIOS/UEFI each time you start the system to tell it to boot Linux.","title":"Week 1"},{"location":"NET264/week1/#net264-unixlinux-system-administration-week-1","text":"","title":"NET264 - Unix/Linux System Administration: Week 1"},{"location":"NET264/week1/#introduction","text":"Welcome to NET264 - Unix/Linux System Administration. The prerequisite to this course is NET220 - Unix/Linux Operating Environments, so you are expected to have some familiarity with Linux systems at this point. In this first week, we'll focus on the history of UNIX/Linux, discussing the duties for a Linux Network Administrator, and some information about man pages and getting help with Linux. Finally, we'll cover some of the installation options you can use to a Linux environment for this class.","title":"Introduction"},{"location":"NET264/week1/#history-of-system-adminstrators","text":"For those of you reading the online 4th edition of the book, the section \"A Brief History of System Administration\" can be found after the Index, in the top level of the book's table of contents. The IBM 701 computer was completed in 1952, and was the first commercial computer system. It was quickly replaced 2 years later by the 704, which was totally incompatible with instructions written for the 701, as it used different word-sizes and added floating point arithmetic. The early operators of these systems layed the foundation for future SysAdmins. The informal meetings between these operators would lead to the IBM funded SHARE group, where operators would share experiences and software. SHARE continues to exist today (https://www.share.org/). These early computer systems were large and expensive, and only really designed to support a single user and task. Therefore, companies would only invest in one if they had a task that was so large and important that it was worth the expense of purchasing and maintaining it. At this point in time, the people in charge of the computers were viewed more as operators than administrators. This began to change in the 1960s, when research into designing multi-user computer systems began. One of the first attempts to develop such an operating system, Multics, was abandoned by the major research group AT&T Bell Labs after 5 years of failed development. Some remnants of this group, Ken Thompson, Rudd Canaday, and Dennis Ritchie, began working on a new system inspried by Multrics, but redesigned it to eliminate many of the pitfalls experienced when developing Multics. This system became known as UNIX, and was originally a small, single-user system. By 1971, this system began implementing many of the commands we still see today in modern Linux, such as as , cat , chdir (now cd ), chmod , chown , cmp , cp , date , and du . By 1973, the advant of the C programming language and idea of piping led to the increase in power of the UNIX operating system, along with a usage and design philosophy: - write programs that do one thing well - write programs that work together - write programs that handle text streams as a universal interface Over the next 15 or so years, the use of UNIX repidly expanded. Anti-trust rulings prevented AT&T from selling UNIX, forcing it to license it to other entities instead. One of the most important recipients of UNIX was Professor Robert Fabry at Cal Berkeley, leading the the development of Berkeley UNIX, later to be named the Berkeley Software Distribution (BSD), one of the OS's most famous distribution. Eventually, this development received funding from the US Defense Advanced Research Project Agency (DARPA). However, when AT&T was broken up do to later anti-trust rulings, it was then able to develop its own commercial distributions of UNIX and sell them. Eventually, this led to them suing Berkeley Sofware Design Inc. (BSDI) for stealing it's code. After 2 years, they were able to get a grand total of 3 out of over 18,000 files removed from BSD. However, this uncertainty led to many entities using UNIX to jump ship to Microsoft NT and Windows to avoid being at the mercy of AT&T. Meanwhile, in 1987, Professor Andrew S. Tanenbaum had released a simplified UNIX distribution called MINIX (mini-UNIX) with his book Operating Systems: Design and Implementation . This book and OS led to Linux Torvalds' development of the Linux kernel. The effect of this is that many UNIX SysAdmins shifted to learning Windows in the mid-1990s, to avoid losing their jobs due to their old skills no longer being relevant. As the dust cleared from the late 90s, it was clear that Windows was going to dominate the computing landscape. However, Linux continued to persist, and it became apparent that businesses would have to use both operating systems. Linux servers have much lower total cost of ownership (TCO) than Windows.","title":"History of System Adminstrators"},{"location":"NET264/week1/#sys-admin-roles-and-responsibilities","text":"The rest of the material in this week is from Chapter 1 of the textbook. If you are using the eBook on Safari, Chapter 1 is in Section One: Basic Administration. While system administrators are not software developers, one of thier major roles is scripting, which will be covered in the next two weeks. Here, we'll briefly discuss the other roles of SysAdmins: - Provisioning Accounts: This inclues adding new accounts for new users, deleting/deactivating accounts for people who no longer need them, and handling other account issues. - Performing Backups: A boring but critical part of being a SysAdmin. There is nothing exciting about backing up server drives, but are critical to ensuring business operations can continue if a server encounters drive damage. - Installing/Updating Software: New software must be tested before being distributed. Many companies disallow general employees from installing their own software, therefore, SysAdmins must also manage the distribution of new software. Additionally, SysAdmins must manage the updating of software, ensuring that new versions do not cause issues, or quickly distributing new updates that fix a security vulnerability. - System Monitoring: SysAdmins must keep track of the system at all times. Users generally will not notice or report minor issues. There are many software solutions for system monitoring that can aid in this task. - Troubleshooting: Admins must handle the process of diagnosing and fixing issues with the system. - Maintaining Local Documentation: Software and systems are configured to meet business needs, meaning additional documentation beyond what is provided by the software/system authors is required. - Monitoring Security: The SysAdmin is responsible for implementing the company security policy, and ensuring it is followed. They must also update the policy when neccessary to reflect changes, as software systems are constantly evolving. SysAdmins must also perform security audits to ensure that systems are not compromised. - Fire Fighting: Hopefully not literally... SysAdmins are responsible for assisting company employees with their computer issues, as well as handling major server failures.","title":"Sys Admin Roles and Responsibilities"},{"location":"NET264/week1/#manual-pages","text":"These are often abbreviated as \"man pages\", as the command man is used to view them. These are online documentation included with the system or software distribution, and provide information about the command/driver/file format/etc. These do not provide answers to general questions about how the software is working, but provide basic information on what the software does, and how to use it. The man command followed by the name of the command/file/etc. that you want information on is used to lookup the manual for that resource. The PAGER environment variable contains the program that is used to display the man page ( more , less , etc.). The section of the manual you want to view can be passed before the title of the resource to view the manual of. Most commands provide a one-line description. The -k followed by a keyword to search for will return all commands that contain the specified keyword in this description. For example: man -k copy asn1_copy_node (3) - API function bcopy (3) - copy byte sequence copy_file_range (2) - Copy a range of data from one file to another copysign (3) - copy sign of a number copysignf (3) - copy sign of a number copysignl (3) - copy sign of a number cp (1) - copy files and directories # ... many more results truncated Man pages are typically stored in directories under /usr/share/man/ . These pages are typically compressed using the gzip compression format, and decompressed when requested. The default search path(s) is(are) stored in the environment variable MANPATH , and can be checked using the manpath command. Beyond the included documentation installed with the system and software, much of the information can be found on the internet. Nowadays, pretty much all vendors provide documentation on their websites. Additionally, community forums exist where users and SysAdmins share problems and solutions. Requests for Comments (RFC) provide definitieve information on internet protocols and procedures. While they are very technical, anyone wanting to know the exact information about a protocol should read the associated RFC.","title":"Manual Pages"},{"location":"NET264/week1/#distros","text":"A distribution (often abbreviated to \"distro\") is the Linux kernel (the core operating system) bundled with additional software. All distros aim to provide simple installation, a package manager, and, in the case of desktop distros, some form of GUI and desktop. Many server installations do not ship with a GUI, and instead only run in terminal mode. When looking at distros for business use, it's important to consider the lifetime of the distribution, the vendor support, security update schedule, and if common software is compatible/frequently updated. There is a Linux family tree, of sorts, where there are few core distros that branch from the original kernel. For example, Debian GNU/Linux is one of the older Linux distributions. From Debian, distros including Ubuntu, Kali, and Knoppix are built off of it. Ubuntu is often called a \"cleaned-up\" version of Debian, and offers a more streamlined user experience. Furthermore, Linux Mint and Pop!_OS are built off of Ubuntu (and, by extension, also built off of Debian). Mint is often recommended as a first Linux distro to Windows users due to its simplicity and similarity to Windows' GUI. To provide a breadth of Linux distros, the book will sometimes discuss specifics of Ubuntu (Debian-based), openSUSE (SUSE based), Red Hat (RHEL-based). To provide details of operating systems more directly built off of UNIX, Solaris, HP-UX, and AIX will be discussed.","title":"Distros"},{"location":"NET264/week1/#installation-options","text":"As you might imagine, you will need your own Linux environment for this class. There are several options to do so, which we'll discuss here: 1. Virtual Machine: This is the easiest and least intrusive option. One thing to note is that you may need to go into your computer's BIOS/UEFI settings and enable virtualization on your CPU. Then, you can install a hypervisor. If you have a professional or above version of Windows, you can enable Hyper-V by going to \"Turn Windows features on or off\". You can also install VMWare Workstation on Windows or VMWare Fusion on mac. However, I have heard that, while free, getting Broadcom (the new owner of VMWare) to provide the installer can be challenging. An option that works across operating systems is Oracle VirtualBox. This is a free and open source hypervisor that works on Windows, Mac, and Linux. Your \"host OS\" is the operating system installed on your computer, so make sure to choose the installer for Windows if you are on Windows, and Mac if you are on Mac. To install Linux, you will need to download the .iso file from the vendor (in this case, Ubuntu). For this class, you should use a desktop version. To create a new VM, select the correct option to create a new VM for your hypervisor. The steps will be slightly different, but you will need to tell it how many CPU cores and how much RAM to dedicate to the VM, and select a location to create the Virtual Hard Disk. You can do this on either your main computer's storage drive, or on an external hard drive you USB thumbdrive. Using a thumbdrive or external drive will be slower, but is an option if you do not have very much storage space remaining on your computer. 2. Separate Drive: You can partition and install Linux on a separate hard drive, either by installing an additional hard disk or SSD into your computer if it allows it, or an external hard drive. If it is an external drive, you'll need to make it bootable. A SATA connected drive will be detected as bootable as soon as you install the OS. To install Linux, you will need to download the .iso file from the vendor, in this case, Ubuntu desktop. Next, you will need a USB flash drive large enough (8GB for newer Ubuntu versions, some older ones may work with 4GB) to store the Linux ISO. Rufus is a commonly used tool for this purpose. Here are the instructions from Ubuntu (https://documentation.ubuntu.com/desktop/en/latest/how-to/create-a-bootable-usb-stick/#on-windows) to create a bootable USB on Windows. There are instructions for Mac below the Windows Section. 3. Dual-Boot on Same Drive : This is the most advanced option. You'll need to go into Windows drive management and shrink your Windows partition. 20GB is the minimum recommended amount of drive space for installing Ubuntu. Once you shrink your Windows partition, you'll need to create a bootable CD or USB (same process as option 2) to install Linux. You then need to restart your computer, enter BIOS/UEFI, and boot from the USB. Then, when using the Linux installer, you should see the unallocated space created by shrinking your Windows partition. Use all this space for Linux. Note: A VM is by far the easiest and cheapest option. I would only recommend the other options if you would like to use Linux as an alternate OS in your day-to-day life. Anything for this class, or even any testing you do in the future, can be done using a VM.","title":"Installation Options"},{"location":"NET264/week1/#installing-linux","text":"Once you get to this point, the steps to install Linux will be the same. You will need to configure the partition table for your Linux system. The first 512 bytes should be dedicated for EFI Boot. The next section is the root (signified by a single forward slash / ). Use \"ext4\" as the file system. I'd recommend dedicating at least 4 GB of RAM to it, but 8 would be better, if you have enough storage. If your VM or computer (depending on the install option) has more than 8 GB of RAM, you can dedicate the rest of the free space to the /home directory. This should also use the ext4 file system. If you have less than 8GB of RAM, I'd recommend dedicating all but 4GB of the remaining free space to /home . After home, add an additional \"swap\" partition. This will provide the OS with virtual RAM to use if it runs out of main memory. From here, you can pretty much just click through all the boxes and the installation will proceed. If you are not using a VM, you may want to consider going back into BIOS/UEFI settings and making your Linux drive/partition the first option. This way, the GRUB menu will appear when you start your system and you can choose whether to boot Linux, or your original OS. Otherwise, you will have to go into BIOS/UEFI each time you start the system to tell it to boot Linux.","title":"Installing Linux"}]}