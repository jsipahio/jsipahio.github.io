# NET264 - Unix/Linux System Administration: Week 4
This week covers Chapters 2 and 3 of the 5th edition book, and Chapters 3 and 4 of the 4th edition book. The topics are Booting, Shut Down, Access Control, and Root elevation. Some details in the 4th edition book are out of date. Consult these notes for updates.
## Booting
The boot process controls how the OS takes control of the computer's hardware when the computer is powered on. The boot process has evolved over the years, but in general it starts with a bootstrapping step, where the computer is powered on, and the hardware is responsible for finding and starting the operating system. Once the OS is loaded into memory, it must start the necessary programs, DLLs, and drivers to interact with the hardware. Finally, the OS can launch its login and hand control over to the user.
### Bootstrapping
At this phase, the computer is highly vulnerable as it is dependent on its hardware to be functional, its configurations to be correct, and for the OS files to be uncorrupted and accessible. Despite the critical nature of bootstrapping and startup, sysadmins often have little control over the process. It is instead controlled by the manufacturer of the hardware. Some machines are purpose built to run UNIX or another proprietary operating system. Therefore, booting the targeted OS is simple. However, nowadays, many machines are PCs, which use BIOS (basic input/output system) or UEFI (unified extensible firmware interface). UEFI was designed to replace BIOS, and is the most commonly now. Colloquially, many people still call UEFI "BIOS", which is the convention I will follow here. If a remark pertains only to the original BIOS, it will be labeled as "legacy BIOS". Notes about UEFI will specifically refer to UEFI. Both are similar in that they are a very basic "operating system" that is installed on the computer's ROM (read-only memory). This is typically installed on the motherboard. The first thing that occurs when a computer's power switch is activated is the loading of BIOS to the computer's main memory to be executed on the CPU. BIOS's first task is the power-on self test (POST), where the system hardware is checked before loading the OS. BIOS allows you to set which devices to boot from, and in which order. BIOS will check for the existence of each device until it finds one to boot from. Legacy BIOS reads the first block of the device for the MBR (master boot record) to determine which partition to load the operating system bootloader from. UEFI reads the GUID Partition Table (GPT, no relation to the LLM) to determine where to boot. It does this by finding the special EFI partition, which has a special GUID (globally unique identifier). The EFI partition contains the GPT and the system bootloader files. At this point, the OS bootloader takes over and BIOS's job is done.
### GRUB
Grand Unified Bootloader (GRUB) is the primary bootloader used by UNIX/Linux systems. Most distros use GRUB 2 now (**this contradicts a dated statement in the 4th edition book**), which is the successor to legacy GRUB. The primary differences are in the format and location of the configuration files, and that GRUB 2 allows the boot screen to be customized. From here on, GRUB means GRUB 2, and legacy GRUB will not be discussed in these notes. The file `/boot/grub/grub.cfg` is the primary configuration for GRUB. However, it should not be directly modified. There is a simpler file, `/etc/default/grub` that is available to be edited to make changes to GRUB's configuration. Most distributions provide a program to apply these changes to the `/boot/grub/grub.cfg`. On Debian-based systems it is `update-grub`. On RHEL-based systems, it is `grub2-mkconfig`.  
GRUB is powerful bootloader that provides options for recovering damaged systems. Upon being given control of the system by BIOS, GRUB will load its configuration and display a splash screen, allowing you to choose which OS kernel to boot. From this screen, a command-line can also be brought up to allow you to modify GRUB's configuration on the fly, or boot an OS kernel that the GRUB splash screen does not know about. Changes made to the configuration in the command line are not saved, however. If you want these changes to persist, you must modify the `grub.cfg` file as described before. The command line also allows you to pass command line arguments to the kernel when booting. This can allow you to boot to single-user mode (like Windows Safe mode) or set `init=/bin/bash` to only load a bash terminal. This provides you with options to recover a damaged system. Another note on the GRUB menu as it pertains to updates. When updating kernels, the new kernel is typically installed alongside the old one, allowing you to boot the old kernel in the event that problems occur with the new kernel. These kernel options will all become available in GRUB, which can pollute the menu. However, if the default kernel is not working, you can try selecting an old one to recover the device. 